[{"title":"所谓bug","path":"/所谓bug/","content":"依然在奋战meta backend api assignment。耗时耗脑远超过预计。 代码写到360行，我已经记不清前边的块块是在什么样的绞尽脑汁和灵光闪烁中完成的了。 但是我有种感觉，不需要去记忆也不必焦虑记不住精确的解决问题路径或步骤，细枝末节的知识点太多（好像还在动态生发），记住全部这相当不符合实际。 我应该建立信心，如果再碰到类似的问题，我大概率能够更加快速地形成思路或找到思路（goofu式微，gptfu崛起）。放眼望去，整个互联网是宽泛意义的知识总库。我可以把对我自己更有价值的信息梳理留存以便查阅、巩固。试图把全网信息收入囊中是徒劳也是无益的，最后怕是沦为复读机了。 就像AI去识别一张图片，像素千千万，ta能够汇成一句“柯基犬”的时候我们知道模型训练的差不多了。提取特征、浓缩标签像是人的本性。类比到代码，每行甚至每个词汇都有其含义（和出错的可能！），成熟的程序员大概就是模块化处理，在清楚细节的背后逻辑的基础上，对某个功能能够流畅地实现，继而宏观整合。庖丁解牛时岂不是胸中有沟壑呢。 从这个意义上讲，bug是老师是明灯，是一个允许用最小的成本来修正提升的无限试错机制。 bug是光！ 庖丁成为高手前不知霍霍了多少头牛呢！调bug成划算了。 下面用一个小小的例子来看看bug可以多么“隐秘而伟大”。 assignment的收尾工作之一 Implement proper filtering, pagination and sorting capabilities for &#x2F;api&#x2F;menu-items and &#x2F;api&#x2F;orders endpoints. Review the videos about Filtering and searching and Pagination as well as the reading More on filtering and pagination. 参考课程材料，2行代码搞定⬇️ Using DRF’s built-in pagination classes makes paginating the API result very easy. Add these two lines in the REST_FRAMEWORK section in the settings.py file. 12&#x27;DEFAULT_PAGINATION_CLASS&#x27;: &#x27;rest_framework.pagination.PageNumberPagination&#x27;,&#x27;PAGE_SIZE&#x27;: 2 然后问题来了。 好家伙，先是自己肉眼核对代码，没发现问题。问小chat，问bing一顿找，有点眉目了。 1234&quot;DEFAULT_PAGINATION_CLASS&quot;: [ &#x27;rest_framework.pagination.PageNumberPagination&#x27;,]&quot;PAGE_SIZE&quot;: 2, 我大概有一会是失明的。吧。对列表熟视无睹。 细想来，是惯性思维作祟了。看它的楼上，队形整整齐齐。。。 12345678910111213141516REST_FRAMEWORK = &#123; &quot;DEFAULT_RENDERER_CLASSES&quot;:[ &quot;rest_framework.renderers.JSONRenderer&quot;, &quot;rest_framework.renderers.BrowsableAPIRenderer&quot;, &quot;rest_framework_xml.renderers.XMLRenderer&quot;, ], &quot;DEFAULT_AUTHENTICATION_CLASSES&quot;:[ &quot;rest_framework.authentication.TokenAuthentication&quot;, &quot;rest_framework.authentication.SessionAuthentication&quot;, ], &quot;DEFAULT_FILTER_BACKENDS&quot;: [ &#x27;django_filters.rest_framework.DjangoFilterBackend&#x27;, &#x27;rest_framework.filters.SearchFilter&#x27;, &#x27;rest_framework.filters.OrderingFilter&#x27;, ],&#125; 记住，计算机没有情绪，不会恶作剧，对错分明。在某种意义上是比人类可靠得多的存在。 所以，遇到bug，莫急莫躁，莫怀疑是不是计算机在搞你，踏踏实实，调！","tags":["django","stuck","bingo"],"categories":["tech"]},{"title":"回文","path":"/回文/","content":"回文含义一个字符串，她的倒序与原文完全一致。 如：aba, fghhgf, t 代码实现Java Question text 按要求写出代码。 编写一个程序，从用户那里读取一个字符串，如果该字符串是一个回文（一个前后拼写相同的词），则打印 “是回文”，如果该字符串不是回文，则打印 “不是回文”，并打印一个新的空行。 最初代码1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.Scanner;public class Lab &#123; /*在这里输入代码*/ public static void main(String [] args)&#123; Scanner scan = new Scanner(System.in); String text = scan.nextLine(); int len = text.length(); //长度为偶数 if( len % 2 == 0) &#123; boolean isHui = true; for(int i=0; i&lt;len/2; ++i) &#123; if(text.charAt(i) != text.charAt(len-1-i)) &#123; System.out.println(&quot;不是回文&quot;); isHui = false; break; &#125; &#125; if(isHui) &#123; System.out.println(&quot;是回文&quot;); &#125; &#125; //长度为奇数 else&#123; boolean isHui = true; for(int i=0; i&lt;(len-1)/2; ++i) &#123; if(text.charAt(i) != text.charAt(len-1-i)) &#123; System.out.println(&quot;不是回文&quot;); isHui = false; break; &#125; &#125; if(isHui) &#123; System.out.println(&quot;是回文&quot;); &#125; &#125; &#125; &#125; 简化以上代码奇数偶数长度合并处理 123456789101112131415161718192021public static void main(String [] args)&#123; Scanner scan = new Scanner(System.in); String text = scan.nextLine(); int len = text.length(); //合并处理 boolean isHui = true; for(int i=0; i&lt;len; ++i) &#123; if(i &gt;= len-1-i) &#123; //仅遍历前半部分索引即覆盖全体 break; &#125; if(text.charAt(i) != text.charAt(len-1-i)) &#123; System.out.println(&quot;不是回文&quot;); isHui = false; break; &#125; &#125; if(isHui) &#123; System.out.println(&quot;是回文&quot;); &#125; &#125; python Question text 请编写一个函数is_palindrome，判断输入的字符串是否是回文。 123456789101112131415param = input()# 在此处编写代码def reverse_string(word): res = &quot;&quot; for le in word: res = le + res return resdef is_palindrome(word): if reverse_string(word) == word: return True return False print(is_palindrome(param)) 注：对str类型，无built-in倒序函数，更多方式参考Reverse string in Python (6 different ways)。 练习-同样思路用Java实现1234567891011121314151617181920212223import java.util.Scanner;public class Approach2 &#123; public static String reverse(String text) &#123; String res = &quot;&quot;; for (int i=0; i&lt;text.length(); ++i) &#123; res = text.charAt(i) + res; &#125; return res; &#125; public static void main(String [] args) &#123; Scanner scan = new Scanner(System.in); String text = scan.nextLine(); if(reverse(text).equals(text)) &#123; //!!! System.out.println(&quot;是回文&quot;); &#125; else &#123; System.out.println(&quot;不是回文&quot;); &#125; &#125;&#125; 💣：对比字符串内容一致，使用strA.equals(strB)!!! 🙅：strA == strB易踩坑 思考我先在循环猫预科Java小测4中遇到这个问题。当时在前几个小测中频繁地使用遍历字符串、逐个对比char的套路，于是在拿到回文问题时自然地着眼于“微观”式的解决方式。 后来补充练习了跳过的python部分，在循环小测中再次遇到同样的问题。此题之前有一个将字符串倒序的练习，那么处理回文时自然想到调用已有的函数，直接“宏观”对比字符串。 宏观背后当然也深入到微观层面进行比对，但是这种分解问题成为更小问题（解耦）各自处理的思路——回文判断VS倒序字符串+对比字符串是否相同，以及函数封装调用的清晰结构呈现，是值得回味的。 也许有人会说，不转换倒序而是逐个比对的方式自有其优势：在遇到不匹配的字符时break loop，不继续遍历了。看似会更有效率，然而想想计算机运算资源的强大和这个问题消耗资源的一般规模，可以想见这种效率的差异是人类无法感知的。这种情况下，让programmer省力是比让机器省力更加明智的选择。 最后，想对python说：优雅，实在优雅。(刘波er语气～) 扩展1参考这篇文章Check for Palindrome Using Python，进行多解练习。 扩展2关于不同方式运行时间差异的考察 udacity project 1有遇到测时间 扩展3230207更新 chatGPT如是说她的想法印证了我关于两种实现方式的分析。一种写起来简洁，一种性能效率佳。 接着问她具体代码⬇️ 12345678910111213141516def is_palindrome(s: str) -&gt; bool: left, right = 0, len(s) - 1 while left &lt; right: if s[left] != s[right]: return False left += 1 right -= 1 return Trueif __name__ == &quot;__main__&quot;: input_string = input(&quot;Enter a string: &quot;) if is_palindrome(input_string): print(&quot;The string is a palindrome.&quot;) else: print(&quot;The string is not a palindrome.&quot;) 代码私教很聪明，但是切勿过度依赖，重点是自己捋清思路、掌握原理。","tags":["Java","python","palindrome"],"categories":["tech"]},{"title":"Troubleshoot - install miniconda in WSL2 ubuntu","path":"/Troubleshoot-install-miniconda-in-WSL2-ubuntu/","content":"update 08&#x2F;27&#x2F;2022 If I setup miniconda path to environment variable in terminal, it works only for that “moment” which means next time I launch terminal all setup will reset so conda won’t be recongnized and response again. To solve it, I need to change setup file once for all. In the path \\wsl$\\Ubuntu-20.04\\home\\sugarmango find .bash_profile Edit the file to add miniconda path to env variable (BTW I set date and greeting and alias to make terminal more handy) Nice! now I can use conda without any prior work. original post 08&#x2F;26&#x2F;2022 In udacity nanodegree - AI programming with python, I start curriculum 3&lt;numpy, pandas, matplotlib&gt; this week after quite a while on project 1 which is demanding but rewarding. I get stuck very soon. well I have envolved from panic to “aha interesting” since lots of hands-on lessons taught me I can solve 90% questions using google-fu. Today is another proof. I use windows for my whole life (poor girl) until I start to learn programming. Mainly javascript and python for the beginning. I follow some tutorial and manage to install WSL2 ( long story ) to use linux particularly ubuntu 20.04. Turns out it’s worthy efforts. I love ubuntu terminal and it helps a lot since tons of guide material using mac os or linux. The aim is to install anaconda&#x2F;miniconda on computer. I select miniconda because A it’s much smaller than anaconda, B the laptop has to be returned since I left my job so less trouble. According to this article, it is easy to install with several commands. The issue is conda can’t response after installation official doc solution says 2 ways uninstall and reinstall - emmm edit path. I try this. the eg seems for win so won’t work for me. I search then find what I want - change env variable in linux looks easy but… ok! error - search - correct -bingo. one space can destroy all. all done! anaconda carry 3.9 python. great.","tags":["problem-solving","ubuntu","wsl"],"categories":["tech"]}]